import jsPDF from 'jspdf';
import { saveAs } from 'file-saver';
import * as XLSX from 'xlsx';

export class DocumentGeneratorService {
  private static instance: DocumentGeneratorService;

  static getInstance(): DocumentGeneratorService {
    if (!DocumentGeneratorService.instance) {
      DocumentGeneratorService.instance = new DocumentGeneratorService();
    }
    return DocumentGeneratorService.instance;
  }

  // PDF Generation
  async generatePDF(content: string, options: {
    title?: string;
    author?: string;
    subject?: string;
    format?: 'a4' | 'letter';
    orientation?: 'portrait' | 'landscape';
  } = {}): Promise<void> {
    const { title = 'Document', author = 'CyberAI', format = 'a4', orientation = 'portrait' } = options;

    const pdf = new jsPDF({
      orientation,
      unit: 'mm',
      format
    });

    // Set document properties
    pdf.setProperties({
      title,
      author,
      subject: options.subject || title,
      creator: 'CyberAI Ultimate'
    });

    // Add title
    pdf.setFontSize(20);
    pdf.text(title, 20, 30);

    // Add content
    pdf.setFontSize(12);
    const lines = pdf.splitTextToSize(content, 170);
    pdf.text(lines, 20, 50);

    // Add footer
    const pageCount = pdf.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      pdf.setFontSize(10);
      pdf.text(`Page ${i} of ${pageCount}`, 20, 280);
      pdf.text(`Generated by CyberAI Ultimate`, 150, 280);
    }

    // Save the PDF
    pdf.save(`${title.replace(/\s+/g, '_')}.pdf`);
  }

  // Excel Generation
  async generateExcel(data: any[], options: {
    filename?: string;
    sheetName?: string;
    headers?: string[];
  } = {}): Promise<void> {
    const { filename = 'data', sheetName = 'Sheet1', headers } = options;

    const workbook = XLSX.utils.book_new();
    
    let worksheet;
    if (headers && data.length > 0) {
      // Create worksheet with custom headers
      worksheet = XLSX.utils.json_to_sheet(data, { header: headers });
    } else {
      // Auto-generate from data
      worksheet = XLSX.utils.json_to_sheet(data);
    }

    // Add styling
    const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1');
    for (let row = range.s.r; row <= range.e.r; row++) {
      for (let col = range.s.c; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
        if (!worksheet[cellAddress]) continue;
        
        // Style header row
        if (row === 0) {
          worksheet[cellAddress].s = {
            font: { bold: true },
            fill: { fgColor: { rgb: 'CCCCCC' } }
          };
        }
      }
    }

    XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
    
    // Generate and save
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    saveAs(blob, `${filename}.xlsx`);
  }

  // Word Document Generation (simplified)
  async generateWord(content: string, options: {
    title?: string;
    filename?: string;
  } = {}): Promise<void> {
    const { title = 'Document', filename = 'document' } = options;

    // Create a simple HTML structure that can be opened in Word
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; }
          h1 { color: #333; border-bottom: 2px solid #333; }
          p { line-height: 1.6; }
        </style>
      </head>
      <body>
        <h1>${title}</h1>
        <div>${content.replace(/\n/g, '<br>')}</div>
        <hr>
        <p><em>Generated by CyberAI Ultimate</em></p>
      </body>
      </html>
    `;

    const blob = new Blob([htmlContent], { type: 'application/msword' });
    saveAs(blob, `${filename}.doc`);
  }

  // PowerPoint Generation (simplified)
  async generatePowerPoint(slides: Array<{
    title: string;
    content: string;
    notes?: string;
  }>, options: {
    title?: string;
    filename?: string;
  } = {}): Promise<void> {
    const { title = 'Presentation', filename = 'presentation' } = options;

    // Create HTML structure for PowerPoint
    let htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${title}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 0; }
          .slide { 
            width: 100%; 
            height: 100vh; 
            padding: 40px; 
            box-sizing: border-box;
            page-break-after: always;
            border: 1px solid #ccc;
            margin-bottom: 20px;
          }
          .slide h1 { color: #333; font-size: 2em; margin-bottom: 20px; }
          .slide-content { font-size: 1.2em; line-height: 1.6; }
          .slide-notes { margin-top: 20px; font-style: italic; color: #666; }
        </style>
      </head>
      <body>
    `;

    slides.forEach((slide, index) => {
      htmlContent += `
        <div class="slide">
          <h1>Slide ${index + 1}: ${slide.title}</h1>
          <div class="slide-content">${slide.content.replace(/\n/g, '<br>')}</div>
          ${slide.notes ? `<div class="slide-notes">Notes: ${slide.notes}</div>` : ''}
        </div>
      `;
    });

    htmlContent += `
        <div style="text-align: center; margin-top: 40px;">
          <p><em>Generated by CyberAI Ultimate</em></p>
        </div>
      </body>
      </html>
    `;

    const blob = new Blob([htmlContent], { type: 'application/vnd.ms-powerpoint' });
    saveAs(blob, `${filename}.ppt`);
  }

  // CSV Generation
  async generateCSV(data: any[], options: {
    filename?: string;
    delimiter?: string;
    headers?: string[];
  } = {}): Promise<void> {
    const { filename = 'data', delimiter = ',', headers } = options;

    let csvContent = '';

    if (headers) {
      csvContent += headers.join(delimiter) + '\n';
    } else if (data.length > 0) {
      csvContent += Object.keys(data[0]).join(delimiter) + '\n';
    }

    data.forEach(row => {
      const values = headers ? 
        headers.map(header => row[header] || '') :
        Object.values(row);
      
      csvContent += values.map(value => 
        typeof value === 'string' && value.includes(delimiter) ? 
          `"${value}"` : value
      ).join(delimiter) + '\n';
    });

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    saveAs(blob, `${filename}.csv`);
  }

  // JSON Generation
  async generateJSON(data: any, options: {
    filename?: string;
    pretty?: boolean;
  } = {}): Promise<void> {
    const { filename = 'data', pretty = true } = options;

    const jsonContent = pretty ? 
      JSON.stringify(data, null, 2) : 
      JSON.stringify(data);

    const blob = new Blob([jsonContent], { type: 'application/json' });
    saveAs(blob, `${filename}.json`);
  }

  // Markdown Generation
  async generateMarkdown(content: string, options: {
    title?: string;
    filename?: string;
    includeMetadata?: boolean;
  } = {}): Promise<void> {
    const { title = 'Document', filename = 'document', includeMetadata = true } = options;

    let markdownContent = '';

    if (includeMetadata) {
      markdownContent += `---
title: ${title}
author: CyberAI Ultimate
date: ${new Date().toISOString().split('T')[0]}
---

`;
    }

    markdownContent += `# ${title}\n\n${content}\n\n---\n*Generated by CyberAI Ultimate*`;

    const blob = new Blob([markdownContent], { type: 'text/markdown' });
    saveAs(blob, `${filename}.md`);
  }

  // HTML Report Generation
  async generateHTMLReport(data: {
    title: string;
    sections: Array<{
      title: string;
      content: string;
      type?: 'text' | 'table' | 'chart';
    }>;
  }, options: {
    filename?: string;
    theme?: 'light' | 'dark';
  } = {}): Promise<void> {
    const { filename = 'report', theme = 'light' } = options;

    const themeStyles = theme === 'dark' ? `
      body { background: #1a1a1a; color: #fff; }
      .section { background: #2a2a2a; border-color: #444; }
      table { background: #2a2a2a; }
      th { background: #333; }
    ` : `
      body { background: #fff; color: #333; }
      .section { background: #f9f9f9; border-color: #ddd; }
      table { background: #fff; }
      th { background: #f5f5f5; }
    `;

    let htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>${data.title}</title>
        <style>
          body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            margin: 0; 
            padding: 40px;
            line-height: 1.6;
          }
          .header { 
            text-align: center; 
            margin-bottom: 40px; 
            border-bottom: 3px solid #007acc;
            padding-bottom: 20px;
          }
          .section { 
            margin-bottom: 30px; 
            padding: 20px; 
            border: 1px solid; 
            border-radius: 8px;
          }
          .section h2 { 
            margin-top: 0; 
            color: #007acc;
          }
          table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 10px 0;
          }
          th, td { 
            padding: 12px; 
            text-align: left; 
            border-bottom: 1px solid #ddd;
          }
          th { 
            font-weight: bold;
          }
          .footer { 
            text-align: center; 
            margin-top: 40px; 
            font-style: italic; 
            color: #666;
          }
          ${themeStyles}
        </style>
      </head>
      <body>
        <div class="header">
          <h1>${data.title}</h1>
          <p>Generated on ${new Date().toLocaleString()}</p>
        </div>
    `;

    data.sections.forEach(section => {
      htmlContent += `
        <div class="section">
          <h2>${section.title}</h2>
          <div>${section.content.replace(/\n/g, '<br>')}</div>
        </div>
      `;
    });

    htmlContent += `
        <div class="footer">
          <p>Generated by CyberAI Ultimate</p>
        </div>
      </body>
      </html>
    `;

    const blob = new Blob([htmlContent], { type: 'text/html' });
    saveAs(blob, `${filename}.html`);
  }
}

export const documentGeneratorService = DocumentGeneratorService.getInstance();